<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-09-13 Mon 00:45 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Computational Type Theory</title>
<meta name="generator" content="Org mode">
<meta name="author" content="jbh">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  body {
  max-width: 40rem;
  padding: 1rem;
  margin: auto;
  }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style> body {background-color: #fafad2} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Computational Type Theory</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Intro">Intro</a>
<ul>
<li><a href="#Voevodsky">Voevodsky</a></li>
<li><a href="#Per%20Martin-Lof">Per Martin-Lof</a></li>
<li><a href="#Robert%20Harper">Robert Harper</a></li>
</ul>
</li>
<li><a href="#Let%27s%20begin">Let's begin</a>
<ul>
<li><a href="#Intro%20to%20Type%20Theory">Intro to Type Theory</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-Intro" class="outline-2">
<h2 id="Intro">Intro</h2>
<div class="outline-text-2" id="text-Intro">
<blockquote>
<p>
"A sufficiently expressive programming language is the foundations for all of mathematics" - <a href="https://youtu.be/LE0SSLizYUI">Robert Harper OPLSS 2018</a>
</p>
</blockquote>

<p>
The goal is to understand the recent developments in computational type theory which came from <a href="https://en.wikipedia.org/wiki/Per_Martin-L%C3%B6f">Per Marin-Lof</a>'s intuitionistic type theory, and <a href="https://en.wikipedia.org/wiki/Vladimir_Voevodsky">Vladimir Voevodsky</a>'s univalent foundations. <a href="https://www.ias.edu/ideas/2014/voevodsky-origins">Voedvodsky</a>'s plan was to create a new foundation for 'all of mathematics', create new proof assistants so mathematicians without pedigree can contribute to global mathematics research since their proofs can easily be verified, that AI can extend a model (itself) and generate it's own proofs for that model, and that math will in the future be done entirely in a programming language because the theory of programming languages he claims is the same thing as mathematical logic, they express the same ideas in a different language, so why not unify them.
</p>
</div>

<div id="outline-container-Voevodsky" class="outline-3">
<h3 id="Voevodsky">Voevodsky</h3>
<div class="outline-text-3" id="text-Voevodsky">
<p>
You should google and read everything you can about Field's medalist Voevodsky and his work at the Institute of Advanced Studies at Princeton. He has many talks on YouTube well worth viewing, too many to list here but we'll watch some later in the workshop. 
</p>

<p>
Here is the quick rundown: Voevodsky found modern math was too complicated for anybody including his peers at the IAS to trust outsider research because there were too many problems found in even proofs written by top mathematicians including problems found in his own proofs. Unless you had some prestigious university pedigree nobody would be able to trust your proofs, so nobody even looks at them. In his words modern math is completely broken as a field and the best way to fix this he thought, was computer assisted proofs that way if some unkown mathematician uploaded a paper it would come with all it's proofs as a program you could run and verify it first so you knew you weren't wasting your time. 
</p>

<p>
An enormous amount of mathematicians and type theory specialists were assembled to produce Homotopy Type Theory (see the HoTT <a href="https://homotopytypetheory.org/book/">book</a>). This was described by Robert Harper to be 'a misadventure in formalisms' who deemed it insufficiently computational, and then this research became Computational Type Theory which is what we are taking here.
</p>

<p>
There is a very good interview with Voevodsky <a href="https://johncarlosbaez.wordpress.com/2017/10/06/vladimir-voevodsky-1966-2017/">here</a>:
</p>

<blockquote>
<p>
When I first started to explore the possibility, computer proof verification was almost a forbidden subject among mathematicians. A conversation about the need for computer proof assistants would invariably drift to Gödel’s incompleteness theorem (which has nothing to do with the actual problem) or to one or two cases of verification of already existing proofs, which were used only to demonstrate how impractical the whole idea was.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-Per%20Martin-Lof" class="outline-3">
<h3 id="Per%20Martin-Lof">Per Martin-Lof</h3>
<div class="outline-text-3" id="text-Per%20Martin-Lof">
<p>
A Swedish logician who takes very advanced subjects and breaks them down that anybody at any level can understand. We will read many of his papers <a href="https://github.com/michaelt/martin-lof">here</a> and the <a href="http://www.cse.chalmers.se/research/group/logic/book/">book</a> <i>Programming in Martin-Lof's Type Theory</i> which Robert Harper assumes the viewer of this lectures is familiar with.  
</p>
</div>
</div>

<div id="outline-container-Robert%20Harper" class="outline-3">
<h3 id="Robert%20Harper">Robert Harper</h3>
<div class="outline-text-3" id="text-Robert%20Harper">
<p>
Most of our material will consist of his lectures and draft book on Computational Type Theory, and his book <a href="http://www.cs.cmu.edu/~rwh/pfpl/">PFPL</a>. He also has a Homotopy type theory recorded lecture seminar we may do time allowing because it's great for explaining higher dimensional types. Robert Harper purposely makes his lectures provocative in order to elicit a response in the reviewer to investigate themselves what he's talking about it which is a good strategy. He will hand out very blunt and honest answers, this will be very refreshing. 
</p>
</div>
</div>
</div>

<div id="outline-container-Let%27s%20begin" class="outline-2">
<h2 id="Let%27s%20begin">Let's begin</h2>
<div class="outline-text-2" id="text-Let%27s%20begin">
<p>
I guess we should start with the Oregon Programming Language Summer school archive from <a href="https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html">2012</a> as that edition gives category theory lectures, proof theory and type theory lectures together to show they are all describing the same thing which is computation. The notation will explained in the proof theory lectures, the PMLTT <a href="http://www.cse.chalmers.se/research/group/logic/book/">book</a> and we can concurrently take a <a href="https://symbolaris.com/course/constlog-schedule.html">constructive logic</a> course to run this logic as a program.
</p>
</div>

<div id="outline-container-Intro%20to%20Type%20Theory" class="outline-3">
<h3 id="Intro%20to%20Type%20Theory">Intro to Type Theory</h3>
<div class="outline-text-3" id="text-Intro%20to%20Type%20Theory">
<ul class="org-ul">
<li><a href="https://youtu.be/9SnefrwBIDc">Type Theory Foundations 1.0</a> - Robert Harper
<ul class="org-ul">
<li>You can also watch the mp4 recordings hosted on the OPLSS 2012 <a href="https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html">archive</a>.</li>
</ul></li>
</ul>

<p>
This is a great lecture and the most accessible of all his lectures, as it's from the very beginning. 'Something is true only if you have a proof' is different than the typical logic we learn in school where to prove something exists, you can assume it doesn't then show a contradiction so it must exist. @16:30 classic Robert Harper comment about the absolute state of modern PL development.
</p>

<p>
Interesting definition what a lemma is, or the lemma rule. Meet/Greatest Lower Bound in real analysis is the infimum or inf, the opposite of the supremum or sup and is shown with examples in Tao's <i>Analysis I</i> starting with Example 6.2.8 ie: the set {1,2,3,&#x2026;} the greatest lower bound is 1, and least upper bound is infinity. If you take an empty set, inf(empty) is infinity, and the sup(empty) is negative infinity, since by definition inf() will move positive to the right on the real number line looking for the 'greatest lower bound' of nothing, while sup() will move negatively left looking for the least upper bound. Since the set is empty and neither exist they just keep on going to infinity in opposite directions.
</p>

<ul class="org-ul">
<li><a href="https://youtu.be/RZfY9FAzF7I">Type Theory Foundations 1.1</a> - Robert Harper</li>
</ul>

<p>
TODO
</p>




























<hr>
<p>
<a href="./index.html">Home</a>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
