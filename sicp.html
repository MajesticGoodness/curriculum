<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-04-11 Thu 18:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How to do Structure and Interpretation of Computer Programs (SICP)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="jbh" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style> body {max-width: 62.5rem; padding: 1rem; margin: auto; background-color: #fafad2} </style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">How to do Structure and Interpretation of Computer Programs (SICP)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgce8b65a">SICP (and SDF) Workshop</a>
<ul>
<li><a href="#orgefc6f3e">SICP in 2024</a></li>
<li><a href="#org0950c86">Optional lectures</a></li>
</ul>
</li>
<li><a href="#orgbd0f8dc">BEGIN</a>
<ul>
<li><a href="#orgb520a2c">Install mit-scheme</a></li>
<li><a href="#org6d93566">IDE/Editor</a></li>
<li><a href="#orga182b09">Begin</a></li>
<li><a href="#org0de2e8f">Chapter 1.x</a></li>
<li><a href="#orgab97d15">Chapter 1.2.1</a></li>
<li><a href="#org2d6d053">Chapter 1.2.2</a></li>
<li><a href="#orgda63912">Chapter 1.2.3</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgce8b65a" class="outline-2">
<h2 id="orgce8b65a">SICP (and SDF) Workshop</h2>
<div class="outline-text-2" id="text-orgce8b65a">
<p>
This exists because if you ask how to learn programming likely someone will shill this book to you due to it being a seminal CS text that's been used for decades. It's easier to do this after you have at least some programming experience because then you won't miss as many details as SICP almost gives you everything at once. Most readers will get hung up on the first few chapters because of the math examples thus give up immediately but they are only examples and not the core of the text so don't give up so easily. We'll figure out all the math. In interviews the authors explained this course was taught at MIT after 2 or 3 semesters of calculus so for that target audience it made sense to use math examples. 
</p>

<p>
SICP is lecture notes that became a book the original 6.001 course had many additional assignments to the book exercises. Some examples of these are <a href="https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/pages/projects/">here</a> and <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/psets/index.html">here</a>. Instead of doing those old 6.001 assignments I'm going to do the 2024 <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/assignments.html">assignments</a> from his 6.945 <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/index.html">course</a> and new book <i>Software Design for Flexibility</i> where many of those assignments point to chapters in SICP.
</p>
</div>

<div id="outline-container-orgefc6f3e" class="outline-3">
<h3 id="orgefc6f3e">SICP in 2024</h3>
<div class="outline-text-3" id="text-orgefc6f3e">
<p>
MIT taught some form of this book in their 6.001 course from 1980 (as lecture notes) until 2007 and I think <a href="https://web.mit.edu/6.001/6.037/">still teaches it</a> in 6.037 (now 6.9550). UC Berkeley teaches a <a href="https://cs61a.org/">Python</a> derivative of the book and there is an authorized <a href="https://sourceacademy.org/sicpjs">JavaScript</a> 2022 version taught at the National University of Singapore but the authors have had to make significant <a href="https://sicp.sourceacademy.org/chapters/prefaces03.html">changes</a> in chapter 4 because of the limitations of JavaScript.
</p>
</div>
</div>

<div id="outline-container-org0950c86" class="outline-3">
<h3 id="org0950c86">Optional lectures</h3>
<div class="outline-text-3" id="text-org0950c86">
<p>
There is lectures from 1986 <a href="https://www.youtube.com/playlist?list=PLE18841CABEA24090">here</a> and if you search YouTube many more recent lectures from Berkeley and countless hackathons or compsci reading groups have videos on working through the book. 
</p>
</div>
</div>
</div>

<div id="outline-container-orgbd0f8dc" class="outline-2">
<h2 id="orgbd0f8dc">BEGIN</h2>
<div class="outline-text-2" id="text-orgbd0f8dc">
</div>
<div id="outline-container-orgb520a2c" class="outline-3">
<h3 id="orgb520a2c">Install mit-scheme</h3>
<div class="outline-text-3" id="text-orgb520a2c">
<p>
To do the book read the <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/">setup instructions</a> from Sussman's grad course and only use <a href="https://www.gnu.org/software/mit-scheme/">mit-scheme</a> or you may have problems in later chapters when we need to use the picture language or <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/psets/ps7/readme.html">parallel.scm</a> or mutable lists. If you have to install a VM try the QEMU image for <a href="https://guix.gnu.org/en/download/">Guix System</a> because it's entire configuration is done using <a href="https://www.gnu.org/software/guile/">scheme</a>. Guile scheme may work for the entire book too but I have no idea, it has a <a href="https://elephly.net/guile-picture-language/manual.html">picture language</a> at least. 
</p>

<p>
I'm aware of #lang sicp in DrRacket and many other 3rd party implementations you can start with those for the first few chapters but if you want to do Sussman's more recent books like SDF you're going to have to use the latest mit-scheme anyway so we may as well begin with using the language the book actually wants us to use.   
</p>
</div>
</div>

<div id="outline-container-org6d93566" class="outline-3">
<h3 id="org6d93566">IDE/Editor</h3>
<div class="outline-text-3" id="text-org6d93566">
<p>
Whatever you use keep some kind of exercise versioning so you can refer to them later in future chapters when the book asks you to use code you've already written. This can be simply saving them as their numbered identifier in the book or however you want. You can type scheme into any text editor, save as filename.scm, run mit-scheme, and load your file in the REPL manipulating it there you don't have to use an IDE. This is trivial with (load "filename.scm"). 
</p>

<p>
The only IDEs I use are emacs and edwin the editor that comes with mit-scheme. Edwin is a clone of an old emacs version (Emacs 18 I believe if you want to find a ref card for it) entirely written in scheme and is what 6.001 and the graduate courses have used for decades. Sussman still uses it as per his 2022 course setup notes. You start edwin with <i>mit-scheme &#x2013;edit</i> and are good to go without needing to install anything else as a scheme shell spawns immediately upon opening and debugging is all built-in. However regular emacs will probably be more familiar to you with 'modern' default behavior like you'll have a GUI menu, ability to highlight and cut+paste with a mouse, delete key won't default to be a backspace etc.    
</p>

<ul class="org-ul">
<li>Editor <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/#org6d580b9">setup</a> from 6.945 and <a href="http://groups.csail.mit.edu/mac/users/gjs/6946/">setup</a> from 6.946 for emacs or edwin</li>
<li>Sussman's .edwin config file <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/.edwin">here</a> for better fonts (save in home directory as .edwin (with the period))</li>
<li>Edwin specific docs <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user/Edwin.html">here</a> (it has a stepper too) 
<ul class="org-ul">
<li>Edwin <a href="http://groups.csail.mit.edu/mac/users/gjs/6946/cheat-sheet.pdf">ref card</a></li>
<li>MIT lab <a href="http://groups.csail.mit.edu/mac/projects/scheme/documentation/nwwyw_4.html#SEC32">doc</a> on Edwin commands and how to use the debugger</li>
</ul></li>
</ul>

<p>
If you choose emacs install vanilla emacs not any of those 'spacemacs' or whatever preconfigured versions that remove the GUI drop down menus. Click Options-&gt;Customize Emacs-&gt;Custom Themes and change the colors around if you want. You won't need a config file everything like MELPA package install is already included (and scheme mode) so you will automatically enter scheme mode when opening any file ending in .scm 
</p>

<p>
I wouldn't recommend <a href="https://paredit.org/screencast/fib-fact.gif">Paredit mode</a> or Geiser or anything until you start writing larger programs in the later chapters because you learn scope in the beginning by seeing how all the parens close blocks of expressions and having something automatically shifting around parens when you don't have experience is going to be rage inducing. When your programs start becoming one big function in chapter 4 then install tools.    
</p>

<p>
Commands:
</p>
<ul class="org-ul">
<li>C-x C-c (exit emacs/edwin) is hold down Ctrl and type x, keep holding Ctrl and type c.</li>
<li>C-h t is hold down Ctrl and type h, release Ctrl and type t (starts the tutorial). 
<ul class="org-ul">
<li>PgUp/PgDn, End/Home, arrow keys and mouse all work too you don't have to use the movement commands in tutorial</li>
</ul></li>
<li>M-x the M is the 'meta' key which on a modern keyboard is usually ALT (sometimes the Windows key) but you can redefine both C and M to be something else.</li>
<li>C-g or Ctrl-g is the escape key if you accidentally screw up mid command and want to try again.</li>
</ul>

<p>
<b>Open multiple screens</b> 
</p>

<p>
In either edwin or emacs: use command C-x C-f and type test.scm to open or make a new file. Use C-x 3 and a new window should open to the right or if you want the new window below use C-x 2. Click on the new window and type C-x b and press enter to switch to the scheme REPL which was the buffer you saw when you first opened the editor. Now you have a screen to enter code with the output beside it. In emacs there is no default scheme buffer (unless you configure one) you have to select from the dropdown menu 'run inferior scheme' or M-x mit-scheme. 
</p>

<p>
<b>Eval code</b>
</p>

<p>
Click on the test.scm buffer and enter some random code:
</p>
<pre class="example">
(define x 3)
(+ x 2)
(+ x 2 2)
"this is a string"
;this is a comment
</pre>

<p>
How do you run this in the REPL? Either M-o or C-M-z (edwin) or follow the emacs GUI menus to 'evaluate region' all described in the <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user/Edwin.html">docs</a> and tutorial. Type C-h m to get a list of available commands in whatever current buffer. To switch out of the help buffer C-x b and default will be test.scm or wherever you were last. You can highlight with the mouse (in emacs) snippets of code and just eval that selected code. 
</p>

<p>
Emacs you can evaluate the entire file with C-c C-l but Lisp/Scheme programming is typically done incrementally you write a function then C-x C-e to run it in the interpreter, switch to the interpreter and give it some sample inputs to test, switch back to write a new function and repeat. If emacs asks what scheme to load type 'mit-scheme'.   
</p>

<p>
<b>Errors</b>
</p>

<p>
If you get something similar:
</p>
<pre class="example">
;Unbound variable: *2
;To continue, call RESTART with an option number:
; (RESTART 3) =&gt; Specify a value to use instead of *2.
; (RESTART 2) =&gt; Define *2 to a given value.
; (RESTART 1) =&gt; Return to read-eval-print level 1.
</pre>
<p>
Then typing (restart 1) will return to the REPL or you can try option 3 and fix the typo, or break/kill it in emacs. The bulk of errors will be parens problems in the beginning but it's how you learn and after a few of them you're much more careful about code and what scope it's in. If you run the debugger type C-h m to get a list of commands (can run that in the REPL too). 
</p>
</div>

<div id="outline-container-org44c89dc" class="outline-4">
<h4 id="org44c89dc">Edwin demo in Lecture 1</h4>
<div class="outline-text-4" id="text-org44c89dc">
<p>
First <a href="https://www.youtube.com/watch?v=-J_xL4IGhJA">lecture</a> from the 1986 series if you want to follow him with edwin like @35:40 in the video:
</p>

<ul class="org-ul">
<li>Start edwin with 'mit-scheme &#x2013;edit'</li>
<li>C-x 2 (split screen like he has)</li>
<li>C-x C-f and type in lecture.scm (it will create this file)</li>
<li>Any expressions eval with C-x C-e 
<ul class="org-ul">
<li>Press tab to indent when he demos 'pretty printing'</li>
</ul></li>
</ul>

<p>
In either the scheme buffer or editor window type C-h m to see all the scheme mode commands like indenting multiple lines of code or all the different eval methods like whole program or one line at a time.
</p>
</div>
</div>
</div>

<div id="outline-container-orga182b09" class="outline-3">
<h3 id="orga182b09">Begin</h3>
<div class="outline-text-3" id="text-orga182b09">
<p>
I'm using the <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html">online version</a> and one of the illicit <a href="http://libgen.is/book/index.php?md5=2E2D076C195F245EED60A5D3B00BE993">pdfs</a> floating around to see the figures which are impossible to read in the online html version.  
</p>
</div>
</div>

<div id="outline-container-org0de2e8f" class="outline-3">
<h3 id="org0de2e8f">Chapter 1.x</h3>
<div class="outline-text-3" id="text-org0de2e8f">
<p>
A computational process I would interpret as a running program or the act of computation itself. A procedure is sometimes called a function in modern programming parlance but the book makes it clear later in this chapter these are different things pointing out how a math function definition is nothing like a procedure. 
</p>

<p>
Ex 1.2 is an example of an impossible to read figure. Use the <a href="http://libgen.is/book/index.php?md5=2E2D076C195F245EED60A5D3B00BE993">pdf</a>.
</p>
<pre class="example">
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
</pre>

<p>
Ex 1.3 simple (cond (and ())) you can write your own test cases/examples too:
</p>
<pre class="example">
(= (three-square-sum 1 2 3) (+ (* 2 2) (* 3 3))
(= (three-square-sum 3 1 2) 13)
(= (three-square-sum 3 2 1) 13)
(= (three-square-sum 1 1 1) 2)
(= (three-square-sum 0 1 0) 1)
</pre>

<p>
Ex 1.4 many languages won't let you do this and is a good example of symbolic programming it evals to (+ a b) if b &gt; 0 or (- a b) if not.  
</p>

<p>
Ex 1.5 (define (p) (p)) is a non-terminating loop where (p) keeps calling itself. Since normal-order doesn't eval subexpressions into values until they are needed (p) is never run because it's never needed as (test 0 (p)) will always evaluate to 0. 
</p>

<p>
Ex 1.6 new-if is a regular procedure so it's input (all the subexpressions) are evaluated first with applicative-order eval. The three inputs to new-if: (good-enough? guess x) returns a boolean, guess is already a value, but (sqrt-iter (improve guess x) x) will just keep improving the guess until the end of days as the cond predicate good-enough? is never reached to stop the recursion. The special-form if/else does not automatically evaluate the else clause it preforms the predicate test first.
</p>

<p>
Ex 1.7 try examples: 
</p>

<pre class="example">
1 ]=&gt; (sqrt 0.0009)
;Value: .04030062264654547

1 ]=&gt; (sqrt 1000000000000000)
;takes forever, infinite loop?
</pre>

<p>
(sqrt 0.0009) should be 0.03 and the gigantic number never terminates. This happens because using our current testing strategy of subtracting the square of the guess from the radicand the epsilon (0.001) isn't precise enough for small numbers and very large numbers clearly they never meet that precision or it takes too long to do so. If we ratio the change in guess with the existing guess, the closer they are together the closer they approach 1 so we can adjust our program to check for this by subtracting that ratio from 1 to see if the two guesses are within epsilon of each other.
</p>

<pre class="example">
(define (good-enough? guess x)
  (&lt; (abs(- 1 (/ (improve guess x) guess))) 0.001))
</pre>

<p>
Now gigantic square roots eval immediately and tiny square roots are close enough to wolfram alpha online calculator precision. 
</p>

<p>
Ex. 1.8 The cube root of 8 is 2 or 2 * 2 * 2. Plugging that into the formula: (8/4 + 4)/3 or 6/3 = 2. All I did was change improve procedure and delete average procedure since it wasn't needed anymore:
</p>

<pre class="example">
(define (improve guess x)
  (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
</pre>

<p>
1.1.8 <i>Black-Box Abstractions</i> if you look at the mit-scheme <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-ref.html#index-exp">documentation</a> and scroll to the index at the bottom you'll find definitions for exp and log which are e<sup>x</sup> and log(x) base e. The square x function defined as (exp (double (log x))) if x is 8 then (exp ~4.16) which is 64. A log is a linearized exponent it tells us what the x in e<sup>x</sup> = 8 is and it's 2.079. If we double that and feed it to e then e<sup>4.16</sup> = 64. We can see this ourselves using <a href="https://www.desmos.com/calculator/gren2g4hrs">desmos</a> go along the x-axis to 2, go up until it meets the blue log line, it lands at y = 0.7 or so. Double that to ~1.4 and travel x-axis to 1.4, go up to the exp(x) line and you'll see you intersect at y = 4 or the square of 2 is 4. Both e and it's log (usually written ln or 'the natural log') are preferred for math modeling because it has properties like the derivative of e is itself, this square property we just learned, and that you can estimate e<sup>x</sup> and ln(x) simply on a piece of paper when working with small displacements. For example e<sup>x</sup> for small x like 0.05 is <a href="https://youtu.be/flge97Jp6uo">1 + x</a> and ln(1 + x) is just x for 'small' x.      
</p>
</div>
</div>

<div id="outline-container-orgab97d15" class="outline-3">
<h3 id="orgab97d15">Chapter 1.2.1</h3>
<div class="outline-text-3" id="text-orgab97d15">
<p>
I rewrote fact-iter to instead be a function nested inside another function, with a 'trampoline' meaning execution falls to the bottom of the function hitting (f 1 n) and bounces back calling f. It's the same as what is in the book except simplified. A factorial is a product of every number up to the nth factorial so 3! is 1x2x3. 
</p>

<pre class="example">
(define (factorial n)
  (define (f total counter)
    (if (&lt; counter 2)
	total
	(f (* total counter) (- counter 1))))
  (f 1 n))

(factorial 6)
(factorial 1)
(factorial 0)
</pre>

<p>
The difference in the book between the delayed chain of operations and the iterated version is called re-entry. The delayed chain has to re-enter the same function before returning a value so must keep all that accounting of state somewhere which we will eventually learn is the stack.
</p>

<p>
Ex 1.9 addition is defined as a function that uses <i>a</i> as a counter and increments <i>b</i> everytime there is still an <i>a</i> left until <i>a</i> = 0. The first function (inc (function call)) is going to return a chain of increments until <i>a</i> = 0 then all delayed increment operations will be done. 
</p>

<p>
Ex 1.10 'concise math definitions' means turn (* 5 n n) into 5n<sup>2</sup> and if you plug in some values to f then f(n) = 2y. If you are using edwin you can run the stepper see the <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user.pdf">manual</a> for mit-scheme. Otherwise hand step:
</p>

<pre class="example">
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(define (g n) (A 1 n))
(define (h n) (A 2 n))

(g 2)
- (A 1 2)
- (A 0 (A 1 1))
- (A 0 (2)) 
- (* 2 2)
- 4

(h 3)
- (A 2 3)
- (A 1 (A 2 2)))
- (A 1 (A 1 (A 2 1)))
- (A 1 (A 1 2))
- (A 1 (A 0 (A 1 1)))
- (A 1 (A 0 (2)))
- (A 1 (* 2 2))
- (A 1 4)
- (A 0 (A 1 3))
- (A 0 (A 0 (A 1 2)))
- (A 0 (A 0 (A 0 (A 0 1))))
- (A 0 (A 0 (A 0 (2))))
- (A 0 (A 0 (4)))
- (A 0 (* 2 4))
- (A 0 (8))
- (* 2 8)
- 16
</pre>

<p>
G seems to produce 2<sup>n</sup> while H generates sequence 2, 4, 16, 65536&#x2026; or \(2^{2^2..}\). 
</p>
</div>
</div>

<div id="outline-container-org2d6d053" class="outline-3">
<h3 id="org2d6d053">Chapter 1.2.2</h3>
<div class="outline-text-3" id="text-org2d6d053">
<p>
Tree recursive processes every element in the input we process requires doubling the amount of work on the rest of the input. Phi or \(\phi\) is a constant like e that is solely here to illustrate that the values of fib(n) grow exponentially with the input and fib(n) is approximately \(\frac{\phi^n}{\sqrt 5}\). This sequence is some kind of exponential between \(\sqrt 2^n\) and \(2^n\) so is bounded by exponentials, thus is an exponential. 
</p>

<p>
The 'golden ratio' is anything satisfying \(\frac{a + b}{a} = \frac{b}{a}\) and is found in taking diagonals of pentagons and other geometry you can look up on YouTube and phi is this ratio. In case it wasn't clear in the book the iterative algorithm comes from the observation that 0, 1, 1, 2, 3, 5.. the next in the sequence is the sum of the previous 2 numbers.   
</p>

<p>
Hand step the count-change procedure with only 2 coins and amount 1: 
</p>

<ul class="org-ul">
<li>(+ (cc 1 2 (+ (cc 1 1) (cc 1 0))))</li>
<li>(+ (cc 1 2 (+ (cc 1 1) 0)))</li>
<li>(+ (cc 1 2 (+ (cc (1 - 1) 0))))</li>
<li>(+ (cc 1 2 (+ 1 0)))</li>
<li>(+ (cc (1 - 2) 1))</li>
<li>(+ 0 1)</li>
<li>1</li>
</ul>

<p>
The computations are delayed as (+) needs two arguments so recursion is unrolled fully then evaluation can begin once it stops with 0 or 1. Of course at each level this algorithm throws the current coin value and amount back into itself to find all combinations of possible coins so it's a tree with branching on every iteration if you write out by hand (count-change 11) like the exercise asks below.   
</p>

<p>
Ex 1.11 write examples 1, 2, 4, 11, 25, 59.. enter it into <a href="https://oeis.org/A100550">OEIS</a> and there's actually a generating function solution a physicist figured out however the assignment wants us to create an iterable procedure. You can use the easy recursive procedure to test your iterative one. I took eqv? from the mit-scheme reference manual.
</p>

<pre class="example">
(define (f n)
  (define (f-iter n1 n2 n3 counter)
    (cond ((&lt; n 3) n)
	  ((= counter n) n1)
	  (else
	   (f-iter (+ n1 (* 2 n2) (* 3 n3)) n1 n2 (+ counter 1)))))
  (f-iter 2 1 0 2))
  
(define (g n)
  (cond ((&lt; n 3 ) n )
	(else (+
	       (g (- n 1))
	       (* 2 (g (- n 2)))
	       (* 3 (g (- n 3)))))))
(and
 (eqv? (f 1) (g 1))
 (eqv? (f 2) (g 2))
 (eqv? (f 3) (g 3))
 (eqv? (f 4) (g 4))
 (eqv? (f 0) (g 0)))
</pre>

<p>
Ex 1.12 Pascal's triangle or array is explained <a href="https://www.youtube.com/watch?v=h0Woqc_5qUE%20">here</a> as the number of paths you can take to get to that number in the array or the number of coefficients in (a + b)<sup>n</sup>  
</p>

<pre class="example">
(define (pascal row col)
  (cond ((= row 0) 1)
	((&gt; col row) 0)
        ((or (= col 0) (= col row)) 1)
        ((or (= col 1) (= col (- row 1))) row)  
        (else (+ (pascal (- row 1) (- col 1))
                 (pascal (- row 1) col)))))                                      
</pre>

<p>
For <a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle#/media/File:Sierpinski_Pascal_triangle.svg">example</a> (pascal 4, 2) is 6. The first and last columns are always 1, the n+1 and n-1 columns are the same as the row number if you start counting from 0. The value of (pascal 4, 2) is the value of (+ (pascal 3, 1) (pascal 3 2)) which is (+ 3 (pascal 2 1) (pascal 2 2)) or (+ 3 2 1). Trying to get a middle column element from row 30 takes a long time as the recursive process is generating a tree branch on almost every remaining input. 
</p>

<p>
You can property test your program by noticing each element in a row of Pascal's array sums to \(2^{(row)}\): 
</p>

<pre class="example">
(define (pascal row col)
  (cond ((= row 0) 1)
	((&gt; col row) 0)
        ((or (= col 0) (= col row)) 1)
        ((or (= col 1) (= col (- row 1))) row)  
        (else (+ (pascal (- row 1) (- col 1))
                 (pascal (- row 1) col)))))

(define (ptest n)
  (define (row-sum count)
    (cond ((= count 0) 1)
	  (else (+ (pascal n count) (row-sum (- count 1))))))
  (row-sum n))

(and
  (eqv? (ptest 2) (* 2 2))
  (eqv? (ptest 3) (* 2 2 2))
  (eqv? (ptest 10) (* 2 2 2 2 2 2 2 2 2 2)))
</pre>

<p>
Ex 1.13 Try some examples in scheme:
</p>

<pre class="example">
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

(define (phi x)
  (/ (x 1 (sqrt 5)) 2))

(define (f n)
  ;; expt and sqrt in mit-scheme reference doc
  (/ (- (expt (phi +) n) (expt (phi -) n)) (sqrt 5)))
</pre>

<p>
Notice phi can accept '-' or '+' as a parameter the benefits of symbolic programming. If you run this and compare (f n) and (fib n) you get exactly the same outputs. The book says to use the definition of fib(n) which is fib(n) = fib(n - 1) + fib(n - 2) and since fib(n) = (f n) we can substitute:
</p>

<p>
\[\frac{\phi^n - \varphi^n}{\sqrt 5} = \frac{\phi^{n-1} - \varphi^{n-1}}{\sqrt 5} + \frac{\phi^{n-2} - \varphi^{n-2}}{\sqrt 5}\]
</p>

<p>
Then it's a matter of manipulating using algebra to get it to the form where phi \(\phi\) and varphi \(\varphi\) can be substituted back in, as done in <a href="https://web.archive.org/web/20230330004617/https://sicp-solutions.net/post/sicp-solution-exercise-1-13/">this solution</a> and you could also take advantage of the fact that phi squared is phi + 1 and varphi squared is varphi - 1. First they multiplied everything by \(\frac{\sqrt 5}{1}\) to clear fractions, rewrote what was left into equivalent ratios, distributed out phi and varphi, then some arithmetic after substituting back in the concrete values of phi and varphi to show both sides are equal. The book asks to prove it is the closest <i>integer</i> to fib(n) meaning a number such as -1 or 1 not 1.5 or any rational. The solution shows how you would take the information of \(\varphi^n\) tending towards 0 and create an inequality showing -1 &lt; (fib n) &lt; 1. You can verify this in the scheme REPL for the above program: (expt (phi -) 3), (expt (phi -) 4), etc. Knowing how to prove this wasn't the point of the chapter which was tree shaped processes can have enormous growth in steps.  
</p>
</div>
</div>

<div id="outline-container-orgda63912" class="outline-3">
<h3 id="orgda63912">Chapter 1.2.3</h3>
<div class="outline-text-3" id="text-orgda63912">
<p>
Watch the <a href="https://www.youtube.com/watch?v=V_7mmwpgJHU">lecture</a> for this chapter where he explains what time and space means the whole lecture is worth watching but the specific time/space explanation starts around 17:09. Time is the amount of steps that are evaluated and space is the amount of data needing to be stored. The numbers 16 and 8 differ by a constant factor of 2 and by a constant factor of 8 but as he says in this analysis we don't care what the constant is just that it is a constant and not changing with the input. Try the iterative procedure in the lecture that uses '1+' and '-1+' both built-in increment/decrement functions. He redefines '+' procedure which you can do in lisp you can rename or redefine anything you want. That iterative procedure uses an accumulator the y parameter keeps incrementing until x is 0 and y is returned.
</p>

<p>
He uses big-O in the lecture and big-theta in the book. O(f(n)) or big-O is an upper bound while \(\theta\)(f(n)) means both a lower and an upper bound. An upper bound for y is y or y<sup>2</sup> or y<sup>y</sup> it doesn't describe the behavior of the process like big-theta does which says a process y grows at least \(\theta\)(y) and at most \(\theta\)(y).     
</p>

<p>
In the book the definition for \(\theta\) is \(k_{1}f(n) \le R(n) \le k_{2}f(n)\) where the two k's represent constants that can be the same or different, R(n) is the actual recursive process and f(n) is the function inside O(f(n)) or \(\theta\)(f(n)). The function inside O() or \(\theta\)() is chosen from a list of existing math functions to best describe the behavior of R(n). If R(n) grows to a n<sup>2</sup> process then R(n) is in O(n<sup>2</sup>).
</p>

<p>
The definition of big-theta is \(k_{1}f(n) \le R(n) \le k_{2}f(n)\) and if R(n) represents time of the recursive process of (fib n):  
\[\frac{1}{\sqrt 5}\cdot\phi^n \le Time(n) \le \frac{1}{\sqrt 5}\cdot\phi^n = \theta(\phi^{n})\]  
</p>

<p>
The definition of big-O is \(R(n) \le kf(n)\) so (fib n) is:
</p>

<p>
\[Time(n) \le \frac{1}{\sqrt 5}\cdot\phi^n = O(\phi^{n})\]  
</p>

<p>
Since phi is equal to 1.6180.. and (1.6)<sup>n</sup> won't grow faster than 2<sup>n</sup> this is another legit upper bound though not as tight:
</p>

<p>
\[Time(n) \le \frac{1}{\sqrt 5}\cdot\phi^n = O(2^{n})\]  
</p>
</div>

<div id="outline-container-org2b929dd" class="outline-4">
<h4 id="org2b929dd">Ex 1.14</h4>
<div class="outline-text-4" id="text-org2b929dd">
<p>
There is a nice graphic <a href="https://sicp-solutions.net/post/sicp-solution-exercise-1-14/">here</a> showing the full (cc 11 5) tree. He used (display) to generate the data to plug into graphviz and we can do the same while adjusting the procedure to count the number of calls or nodes in the process tree. Zero out the cond then in the else add 2 for 2 calls to cc:
</p>

<pre class="example">
(define (count-nodes amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (display "(cc ") (display amount) (display " ") (display kinds-of-coins) (display ")") (newline)
  (cond ((= amount 0) 0)
        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)
        (else (+ 2 ( + (cc amount (- kinds-of-coins 1))
                   (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins))))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

1 ]=&gt; (count-nodes 1)
(cc 1 5)
(cc -49 5)
(cc 1 4)
(cc -24 4)
(cc 1 3)
(cc -9 3)
(cc 1 2)
(cc -4 2)
(cc 1 1)
(cc 0 1)
(cc 1 0)
;Value: 10
</pre>

<p>
We can do the same for the fib function and compare the result to the tree in the book (14 nodes not including the root) 
</p>

<pre class="example">
(define (fib-nodes n)
  (cond ((= n 0) 0)
        ((= n 1) 0)
        (else (+ 2 (fib-nodes (- n 1))
                 (fib-nodes (- n 2))))))

1 ]=&gt; (fib-nodes 5)
;Value: 14
</pre>

<p>
We can see count-change grows much less than fib:
</p>

<pre class="example">
1 ]=&gt; (fib-nodes 20)
;Value: 21890

1 ]=&gt; (fib-nodes 30)
;Value: 2692536

1 ]=&gt; (count-nodes 20)
;Value: 150

1 ]=&gt; (count-nodes 30)
;Value: 390
</pre>

<p>
Space is defined as the max depth of the longest tree branch because we only have to keep track of the nodes above us and count-change longest branch is whatever the input is since if there's a coin size of 1 it will take as a minimum n nodes of space of n-sized input so space's lowest bound is n. We can always find some constant to multiply n by in order to represent the rest of the space used in the tree for the other coin denominations meaning space is \(\theta(n)\) it won't grow more than n (times a constant) and grows at least the same size of the input. 
</p>

<p>
To estimate the growth in the amount of steps try gathering data and plot it:   
</p>

<p>
1 ]=&gt; (count-nodes 100)
;Value: 15498
</p>

<p>
1 ]=&gt; (count-nodes 200)
;Value: 229588
</p>

<p>
1 ]=&gt; (count-nodes 300)
;Value: 1292590
</p>

<p>
1 ]=&gt; (count-nodes 400)
;Value: 4642024
</p>

<p>
1 ]=&gt; (count-nodes 500)
;Value: 12822610
</p>

<p>
1 ]=&gt; (count-nodes 600)
;Value: 29806268
</p>

<p>
1 ]=&gt; (count-nodes 700)
;Value: 61312118
</p>

<p>
1 ]=&gt; (count-nodes 800)
;Value: 115126480
</p>

<p>
1 ]=&gt; (count-nodes 900)
;Value: 201422874
</p>

<p>
Plug it into a desmos like I did <a href="https://www.desmos.com/calculator/2l7d4qebm8">here</a> you can see for up to 900 inputs it's bounded by x<sup>3</sup> growth but if you keep going then the points approach the y-axis quickly. As you add 100 to the input the nodes appear to double in size from input 600 to 900 so we can can just keep approximating and doubling the last value of nodes and see by the time you hit x = 1100 then the x<sup>3</sup> curve is already no longer bounding. If you keep going then it eventually passes x<sup>4</sup> too but it will always be bounded by x<sup>5</sup> and that is the critical insight to big-O or big theta the inputs are supposed to be approaching infinity so no matter how big of an input you can guarantee the bound. 
</p>
</div>
</div>

<div id="outline-container-orgb2dd323" class="outline-4">
<h4 id="orgb2dd323">Ex 1.15</h4>
<div class="outline-text-4" id="text-orgb2dd323">
<p>
Build another step counter
</p>

<pre class="example">
(define (count c angle)
  (display c) (display " ") (display angle) (newline)
  (if (not (&gt; (abs angle) 0.1))
      c 
      (count (+ c 1) (/ angle 3.0))))
(count 0 12.5)

1 ]=&gt;
1 4.166666666666667
2 1.388888888888889
3 .462962962962963
4 .154320987654321
5 5.1440329218107005e-2
;Value: 5

(count 0 100)
1 ]=&gt; 
;Value: 7

(count 0 1000)
1 ]=&gt; 
;Value: 9
</pre>

<p>
(p (p (p (p (p 0.05144))))) once the recursion stops and angle is returned then p can start to reduce. Try log<sub>2</sub>(100) and log<sub>2</sub>(1000) and (sine a) is logarithmic in steps. We multiplied the steps by 10 and only added 2 more. Space is the bookkeeping we have to save and is the depth of p so also \(\theta\)(log(a)) as the assignment wants us to express it as a function of <i>a</i>.
</p>

<p>
TODO
</p>
<hr />
</div>
</div>
</div>
</div>
</div>
</body>
</html>
